#!/usr/bin/env python
from __future__ import print_function

__doc__ = """compare structures of two XML documents"""
# 2013-01-11 11:19 Reece Hart <reecehart@gmail.com>

import argparse,ConfigParser,logging,os,sys
import lxml.etree as le
import hashlib

logging_levels = [logging.ERROR, logging.WARN, logging.INFO, logging.DEBUG]

def parse_args(argv):
    ap = argparse.ArgumentParser(
        description = __doc__,
        formatter_class = argparse.ArgumentDefaultsHelpFormatter,
        )
    ap.add_argument('file_A')
    ap.add_argument('file_B')
    ap.add_argument('--conf-file', '-c', metavar="FILE",
                    default = [],
                    action = 'append',
                    help="config file")
    ap.add_argument('--indent-string',
                    help = 'string unit used to indent each level of tree',
                    default = '  ')
    ap.add_argument('--verbose', '-v',
                    default = 0,
                    action = 'count',
                    help = 'be more chatty')
    args = ap.parse_args( argv )
    return args


def compare_nodes(node_a, node_b, path=[], opts=None):
    """compare two XML nodes recursively"""
    def _ifelse(b,opt1,opt2):
        return opt1 if b else opt2

    def _attr_str(e):
        return ' '.join(['%s="%s"'%(k,v) 
                         for k,v in sorted(e.attrib.iteritems())])

    def _label(e):
        "return prettified string repr of node"
        return '%s [%s]' % (
            e.tag, _attr_str(e))

    def _fingerprint(e):
        "return hash of xml subtree content"
        return hashlib.md5( le.tostring(e) ).hexdigest()

    def _find_matching_node(query, targets, opts):
        """find query within targets that matches child according to opts;
        return None if no match or multiple matches"""
        matches = [ t for t in targets 
                    if query.tag == t.tag and query.attrib == t.attrib ]

        if len(matches) == 0:
            return None
        if len(matches) == 1:
            return matches[0]

        # multiple matches. Try to disambiguate by user-provided key or 
        # (default) fingerprinting
        match_count = len(matches)
        key_gen = lambda e: _fingerprint(e)
        how = 'tree fingerprint'
        try:
            key_xpath = opts.conf.get('element-unique-keys', query.tag)
            key_gen = lambda e: ''.join(e.xpath(key_xpath))
            how = 'xpath (%s)' % key_xpath
        except (NoSectionError, NoOptionError):
            pass

        q_key = key_gen(query)
        matches = [ t for t in matches
                    if key_gen(t) == q_key ]
        logging.warn("multiple (%d) matches for <%s %s>; reduced to %d by %s" % (
                match_count, query.tag, _attr_str(query), len(matches), how ))

        return matches[0] if len(matches) == 1 else None
    
    assert node_a is not None or node_b is not None, \
        'Recursed with compare_nodes(None,None)'

    if node_a is not None:
        children_a = node_a.getchildren()
        children_a = [ e for e in children_a if type(e) != le._Comment ]
        childtags_a = set([n.tag for n in children_a])
    if node_b is not None:
        children_b = node_b.getchildren()
        children_b = [ e for e in children_b if type(e) != le._Comment ]
        childtags_b = set([n.tag for n in children_b])

    if node_a is not None and node_b is not None:
        match_string =  ''.join([
                'AB',
                _ifelse(node_a.tag == node_b.tag,           ' ', 'T'),
                _ifelse(node_a.attrib == node_b.attrib,     ' ', '@'),
                _ifelse(childtags_a == childtags_b,         ' ', 'C'),
                _ifelse(len(children_a) == len(children_b), ' ', '#'),
                ])
        label = _label(node_a)
    elif node_a is not None:
        match_string = 'A '
        label = _label(node_a)
    elif node_b is not None:
        match_string = ' B'
        label = _label(node_b)

    indent = opts.indent_string * len(path)
    #path_string = '/'.join([e.tag for e in path] + [label])
    path_string = label
    print( match_string.ljust(8), indent, path_string )

    if node_a is not None and node_b is not None:
        # compare children in A with matches in B
        for child_a in children_a:
            child_b = _find_matching_node(child_a, children_b, opts)
            compare_nodes(child_a, child_b,
                          path = path + [node_a], opts=opts)
        # list any B children not in A
        for child_b in children_b:
            child_a = _find_matching_node(child_b, children_a, opts)
            if child_a is None:
                compare_nodes(child_a, child_b,
                              path = path + [node_a], opts=opts)


if __name__ == '__main__':
    opts = parse_args(sys.argv[1:])

    logging.basicConfig(level = logging_levels[opts.verbose],
                        format = '%(levelname)s: %(msg)s')

    opts.conf = ConfigParser.SafeConfigParser()
    for fn in opts.conf_file:
        opts.conf.readfp(open(fn))
        logging.debug('read '+fn)

    doc_a = le.parse(opts.file_A)
    logging.debug('parsed file_A (%s)' % (opts.file_A))
    doc_b = le.parse(opts.file_B)
    logging.debug('parsed file_B (%s)' % (opts.file_B))
    compare_nodes(doc_a.getroot(), doc_b.getroot(), opts=opts)

#!/usr/bin/env python
from __future__ import print_function

__doc__ = """compare structures of two XML documents"""
# 2013-01-11 11:19 Reece Hart <reecehart@gmail.com>

import argparse,ConfigParser,logging,os,sys
import lxml.etree as le
import hashlib

indent_string = '  '

logging_levels = [logging.ERROR, logging.WARN, logging.INFO, logging.DEBUG]

def parse_args(argv):
    ap = argparse.ArgumentParser(
        description = __doc__,
        formatter_class = argparse.ArgumentDefaultsHelpFormatter,
        )
    ap.add_argument('fileA')
    ap.add_argument('fileB')
    ap.add_argument('--conf-file', '-c', metavar="FILE",
                    default = [],
                    action = 'append',
                    help="config file")
    ap.add_argument('--verbose', '-v',
                    default = 0,
                    action = 'count',
                    help = 'be more chatty')
    args = ap.parse_args( argv )
    return args


def compare_nodes(node_a, node_b, path=[], opts=None):
    """compare two XML nodes recursively"""
    def _ifelse(b,opt1,opt2):
        return opt1 if b else opt2

    def _attr_str(e):
        return ' '.join(['%s="%s"'%(k,v) 
                         for k,v in sorted(e.attrib.iteritems())])

    def _label(e):
        "return prettified string repr of node"
        return '%s [%s]' % (
            e.tag, _attr_str(e))

    def _fingerprint(e):
        "return hash of xml subtree content"
        return hashlib.md5( le.tostring(e) ).hexdigest()

    def _find_matching_node(query, targets, opts):
        """find query within targets that matches child according to opts;
        return None if no match or multiple matches"""
        matches = [ t
                    for t in targets
                    if (query.tag == t.tag
                        and query.attrib == t.attrib) ]
        match_count = len(matches)
        if match_count > 1:
            # matched multiple nodes... try to find one by fingerprinting
            # by definition, this succeeds only if the b side matches exactly
            # ... which make this a bit lame. 
            q_fp = _fingerprint(query)
            matches = [ t for t in matches
                        if _fingerprint(t) == q_fp ]
            logging.warn("multiple (%d) matches for <%s %s>; reduced to %d after fingerprinting" % (
                    match_count, query.tag, _attr_str(query), len(matches) ))

        return matches[0] if len(matches) == 1 else None
    
    assert node_a is not None or node_b is not None, \
        'Recursed with compare_nodes(None,None)'

    if node_a is not None:
        children_a = node_a.getchildren()
        children_a = [ e for e in children_a if type(e) != le._Comment ]
        childtags_a = set([n.tag for n in children_a])
    if node_b is not None:
        children_b = node_b.getchildren()
        children_b = [ e for e in children_b if type(e) != le._Comment ]
        childtags_b = set([n.tag for n in children_b])

    if node_a is not None and node_b is not None:
        match_string =  ''.join([
                'AB',
                _ifelse(node_a.tag == node_b.tag,           ' ', 'T'),
                _ifelse(node_a.attrib == node_b.attrib,     ' ', '@'),
                _ifelse(childtags_a == childtags_b,         ' ', 'C'),
                _ifelse(len(children_a) == len(children_b), ' ', '#'),
                ])
        label = _label(node_a)
    elif node_a is not None:
        match_string = 'A '
        label = _label(node_a)
    elif node_b is not None:
        match_string = ' B'
        label = _label(node_b)

    indent = indent_string * len(path)
    #path_string = '/'.join([e.tag for e in path] + [label])
    path_string = label
    print( match_string.ljust(8), indent, path_string )

    if node_a is not None and node_b is not None:
        # compare children in A with matches in B
        for child_a in children_a:
            child_b = _find_matching_node(child_a, children_b, opts)
            compare_nodes(child_a, child_b,
                          path = path + [node_a], opts=opts)
        # list any B children not in A
        for child_b in children_b:
            child_a = _find_matching_node(child_b, children_a, opts)
            if child_a is None:
                compare_nodes(child_a, child_b,
                              path = path + [node_a], opts=opts)


if __name__ == '__main__':
    opts = parse_args(sys.argv[1:])

    logging.basicConfig(level = logging_levels[opts.verbose],
                        format = '%(level)s: %(msg)s')

    for fn in opts.conf_file:
        cp.readfp(open(fn))
        logging.debug('read '+fn)

    doc_a = le.parse(opts.fileA)
    doc_b = le.parse(opts.fileB)
    compare_nodes(doc_a.getroot(), doc_b.getroot())

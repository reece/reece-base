#!/usr/bin/env python3
"""wipe block device with random data quickly

WARNING: This program provides fast but incomplete disk erasure.

Most erasure methods focus on secure wiping of media, often by making
several passes across the disk with zeros, random data, and various
patterns.  On large drives, hardened erasure of this sort can take
days.

This script has a different goal: surgically spoil a disk in a short
time in order to impede casual efforts at recovery. The intent is to
prevent random Joes from being able to easily mount disks and read
data.

See also: dd, pv, scrub, shred, srm (secure-delete), wipe

"""


import logging
import fcntl
import random
import os
import re
import stat
import subprocess
import sys

import coloredlogs
from tqdm import tqdm

_logger = logging.getLogger()

BLKFLSBUF = 0x00001261 # <include/linux/fs.h>


fdisk_info_re = re.compile(
    r", (?P<size>\d+) bytes, (?P<sectors>\d+) sectors.+Disk model:\s+(?P<serial>\S+).+Sector"
    r" size \(logical/physical\): (?P<lss>\d+) bytes / (?P<pss>\d+) bytes", re.DOTALL | re.MULTILINE)


def get_device_info(dev):
    p = subprocess.run(["fdisk", "-l", dev], capture_output=True)
    if p.returncode != 0:
        raise Exception(p.stderr)
    m = fdisk_info_re.search(p.stdout.decode())
    if not m:
        raise Exception(f"{dev}: Failed to parse fdisk output")
    d = m.groupdict()
    d["size"] = int(d["size"])
    d["sectors"] = int(d["sectors"])
    d["pss"] = int(d["pss"])
    d["lss"] = int(d["lss"])
    return d


# def wipe_random_pos()
# def wipe_modulo()
# def wipe_e2fs() -- read dumpe2fs, scrub named blocks
# def wipe_partition_table()


if __name__ == "__main__":
    coloredlogs.install(level="INFO")
    
    dev = sys.argv[1]
    
    st = os.stat(dev)
    if not stat.S_ISBLK(st.st_mode):
        raise ValueError(f"{dev}: Not a block device")

    device_info = get_device_info(dev)
    print(f"{dev} {device_info}")

    fd = os.open(dev, os.O_RDWR)
    pos = os.lseek(fd, 0, os.SEEK_END)
    assert pos == device_info["size"]

    N = 50000
    n_bytes = 4 * 2**10         # 4KiB; should be fs block size

    #for i in tqdm(range(N)):
    #    p = random.randrange(device_info["size"])
    #    os.lseek(fd, p, os.SEEK_SET)
    #    os.write(fd, os.urandom(n_bytes))

    # primes from https://primes.utm.edu/curios/index.php?start=8&stop=10
    #step_size =   55555553
    #step_size =  100000007
    step_size =   987654103
    #step_size = 9999999929

    # p = random.randrange(device_info["size"])
    p = 0                       # start at 0 to zap partition table

    pbar = tqdm(range(N))
    for i in pbar:
        pbar.set_description(f"{p:15d}")
        os.lseek(fd, p, os.SEEK_SET)
        os.write(fd, os.urandom(n_bytes))
        p += step_size
        p %= device_info["size"] - 1

    
    fcntl.ioctl(fd, 
